<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WDD 330 Portfolio | Annie Hawley</title>
  <meta name="description"
    content="WDD 330 Course Portfolio: Web Frontend Development at Brigham Young University - Idaho">
    <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="content">
    <h1>WDD 330 Portfolio</h1>
  </header>
  <main class="content">
    <h2>Week 03</h2>

    <p class="topic">Object methods, "this"</p>
    <p>1. "this" keyword refers to the object it belongs to.</p>
    <p>2. <span class="comment">"this" in a method</span><br>
    Example:

    const person = <br>
     &nbsp;&nbsp;&nbsp; firstName: "John",<br>
     &nbsp;&nbsp;&nbsp;lastName: "Doe",<br>
     &nbsp;&nbsp;&nbsp;id: 5566,<br>
     &nbsp;&nbsp;&nbsp;fullName : function(){<br>
      &nbsp;&nbsp;&nbsp;&nbsp; return this.firstName + " " + this.lastName;<br>
      &nbsp;&nbsp;&nbsp;}<br>
    };<br><br>

    <span class="comment">So in this example, person.fullName(); will return John Doe<br>
    "this" refers to the person object and the person object owns the fullName method</span><br><br>
  
    3. <span class="comment">"this" in Object construction</span><br>
    function Human (age) {<br>
     &nbsp;&nbsp; this.age = age<br>
    }<br><br>
    
    let greg = new Human(22)<br>
    let thomas = new Human(24)<br><br>

    <span class="comment">In this example, "this" refers to the instance. Greg and Thomas are the instance of Human </span><br><br>

    4. <span class="comment">"this" in Event Listeners</span><br>
    let button = document.querySelector('button')<br>

button.addEventListener('click', function() {<br>
  &nbsp;&nbsp;console.log(this) // button<br>

})<br><br>

<span class="comment">"this" is set to the element that fired the event in an even listener.</span><br>


<span class="comment">**I'm still a little confuse by the "this" keyword. I guess I will be able understand when I finally use it in my code.</span></p>

<br>
<p class="topic">Objects</p>

<p>1. Creating Objects<br></br>

const name = 'Iron Man';<br>
const realName = 'Tony Stark';<br>

<i>// long way</i> <br>
const ironMan = { name: name, realName: realName };<br>
<i>// short ES6 way - the property key is the same as the variable name</i><br>
const ironMan = {name, realName};<br></p>

<p>2. Access properties of an object using the dot notation - superman.name -  or bracket notation - superman['name']</p>
<p>3. To call an object's method, also use the dot or bracket notation - superman.fly() or superman['fly]() --- parentheses is needed after the method name.</p>
<p>4. The "in" operator can be used to check whether an object has a particular property. Example: 'city' in superman; or superman.city !== undefined</p>
<p>5. Can also use hasOwnProperty - superman.hasOwnProperty('city')</p>
<p>6. To find all the properties in an object, use <em>for in</em> loop. Example: <br><br>
  for(const key in superman) <br>
    &nbsp;&nbsp;console.log(key + ": " + superman[key]);<br>
}<br><br>

for(const key in superman) {<br>
  &nbsp;if(superman.hasOwnProperty(key)){  ---  <span class="comment">to make sure that only the object's own properties are returned<br></span>
    &nbsp;&nbsp;console.log(key + ": " + superman[key]);<br>
  }<br>
}<br> </p>
<p>7. Object.keys() method will return an array of all the keys of any object that is provided as an argument, while Object.values() will return an arrays of all the values. </p>
<p>8. Adding properties - superman.city = 'Metropolis' -- <span class="comment"> just assign a value to the new property</span></p>
<p class="comment">*** Properties don't appear on the way they are entered, not an ordered list like array, set or map.</p>
<p>9. Change the value of the properties -- superman['real name'] = 'Ka-el';</p>
<p>10. Use <em>delete</em>to remove any property. Ex: delete superman.fly</p>
<p>11. An object literal can be passed as a parameter to a function, and arguments can be in any order</p>
<p>12. A regular expression (or RegExp, for short) is a pattern that can be used to search strings for matches to the pattern. Ex.  if looking for any word ending in 'ing', could use the regular expression /[a-zA-Z]+ing$/<br>
To test the pattern:<br>
pattern.test('joke');<br>
<< false<br>

pattern.test('joking');<br>
<< true<br>

pattern.test('jokingly');<br>
<< false</p>

<p>13. Character Groups <br>
  const vowels = /[aeiou]/  -- matches any vowel <br>
  /[A-Z]/ - all uppercase letters<br>
  /[0-9]/ - numbers 0 to 9<br>
  /[^A-Z]/ - any character that is not capital letter <br><br>

  pattern = /[Jj][aeiou]v[aeiou]/; ---  represents the letter J (lowercase or capital) followed by a vowel, followed by a lowercase v, followed by a vowel: <br><br>
<< /[Jj][aeiou]v[aeiou]/<br>

pattern.test('JavaScript');<br>
<< true<br>

pattern.test('jive');<br>
<< true<br>

pattern.test('hello');<br>
<< false<br></p>

<br>
<p class="topic">Document Object Model</p>
<p>Example being used: - <a href="heroes.html">Heroes.html</a></p>
<p>1. <em>Document.body</em> returns the body element of a web page<br>

  <em>Document.images</em> returns a node list of all the images contained in the document.<br>
  
  <em>Document.links</em> returns a node list of all the <a> elements and <area> elements that have an href attribute.<br>
  
  <em>Document.anchors</em> returns a node list of all the <a> elements that have a name attribute.<br>
  
  <em>Document.forms</em> returns a node list of all the forms in the document</p>

  <p>2. const wonderWoman = document.querySelector('li:last-child'); -- will return only the last item in the document</p>
  <p>3. const batman = ul.querySelector('li#bats') --  will find an li element with an id of bats</li></p>
  <p>childNodes  - will return all of the child notes of the node concerned including text nodes</p>
  <p>children - will not include text nodes</p>
  <p>firstChild - returns the first child of a node</p>
  <p>lastChild - returns the last child of a node</p>
  <p><span class="comment">***The first child and last child of the node ul is not li, it is text nodes generated by the white space characters between ul and li</span></p>
  <p>parentNode - returns the parent node of an element.</p>
  <p>4. Finding the Value of a Node<br><br>
    getAttribute() - returns the value of the attribute<br>
    setAttribute - change the value of an element's attributes , takes two arguments - the attribute want to change and the new value of that attribute<br>
    Example: <br>
    wonderWoman.setAttribute('class', 'villain');<br><br>

    ***<span class="comment">If the element does not have an attribute, the setAttribute can be used to add an attribute to an element</span><br>
    <p>5.Can also use the dot notation to access the attributes. Ex wonderWoman.id</p>
    <p>6. classList -- list of all the classes an element has<br><br>
    <span class="comment">** Use classList instead of className to modify the name of an element to avoid overwriting all the classes.</span><br><br>
    add - add a class to an element without overwriting any classes that already exist. Ex wonderWoman.classList.add('warrior')<br>
    remove - will remove a specific class from an element<br>
    toggle - add a class if an element doesnâ€™t have it already, and remove the class if it does have it. It returns true if the class was added and false if it was removed. For example:<br>
      wonderWoman.classList.toggle('hero'); <span class="comment">// will remove the 'hero' class</span><br>
      wonderWoman.classList.toggle('sport'); <span class="comment">// will add the 'hero' class back</span><br>
      contains - check to see if an element has a particular class</p>

      <p>7. Creating a new element with text content: <br><br>
      a. Create the element node -- const flash = document.createElement('li');<br>

      b. Create the text node -- flash.textContent = 'Flash';<br>
      
      c. Append the text node to the element node -- flash.appendChild(flashText); </p>

      <p>8. Create elements using function:<br><br>
        function createElement (tag,text) {<br>
          &nbsp; &nbsp;const el = document.createElement(tag);<br>
          &nbsp;&nbsp;el.textContent = text;<br>
          &nbsp;&nbsp;&nbsp;return el<br>
      }<br>

      <span class="comment">use the function above to create another list item element:</span><br>
      const aquaman = createElement('li','Aquaman');<br>
      <p>9. Updating CSS</p>
      <p>a. Any CSS property names that are separated by dashes must be written in camelCase notation. Ex background-color --- backgroundColor</p>
      <p>b. display - make elements appear and disappear. Ex superman.style.display = 'none'; ----> reappear using block Ex. superman.style.display = "block";</p>
      <p class="comment">*** It is much better to keep relevant styles in a separate stylesheet than to use the style property.</p>
      <br>

      <p class="topic">Events</p>
      <p>1. Event listeners - runs when the user clicks anywhere on the page and it is the recommended way of dealing with events. <br>
        document.body.addEventListener("click", doSomething);</p>
        <p><a href="events.html">Code sample</a></p>
        <p>console.log(event.type) - tells what type of event was logged<br>
        <span class="comment">**the parameter event can be any variable, but programmers shortened it to (e) -- now I know what that (e) stands for :)</span></p>
        <p>2. Mouse events</p>
        <p>mousedown<br>
          mouseup<br>
          mouseover<br>
          mouseout<br>
          mousemove<br><br>
          Example:<br>
          const mouseParagraph = document.getElementById('mouse');<br>
mouseParagraph.addEventListener('mouseover', highlight);<br>
mouseParagraph.addEventListener('mouseout', highlight);<br>
        </p>
        <p>dblclick- occurs when the user doubleclicks on the element to which the event listener is attached.</p>
        <p class="comment">** Be careful in using click and dbclick events to the same element because the doubleclick event will always cause the click even to fire.</p>
        <p>3. Keyboard Events</p>
        <P>keydown event occurs when a key is pressed and will continue to occur if the key is held down.<br>
          keypress event occurs after a keydown event but before a keyup event<br>
          keyup event occurs when a key is released.</p>
          <p class="comment">**The keydown event is the action of pressing a key, whereas the keypress event is the action of a character being typed on the screen.</p>

          <p>4. Touch Events </p>
          <p class="comment">** Use in touch-screen devices - can be made with a finger, and also with a stylus or another body part</p>
          <p class="comment">** It's important to support both mouse event and touch event because some devices have both mouse and touch interactions.</p>
          <p>touchstart -  occurs when a user initially touches the surface.<br>
            touchend - occurs when a user stops touching the surface:<br>
            touchmove - occurs after a user has touched the screen then moves around without leaving<br>
            touchenter - occurs when a user has already started touching the surface, but then passes over the element to which the event listener is attached. <br>
            touchleave - occurs when the user is still touching the surface, but leaves the element to which the event listener is attached.<br>
            touchcancel - occurs when a touch event is interrupted, such as a userâ€™s finger moving outside the document window, or too many fingers being used at once. A pop-up dialog will also cancel a touch event.</p>

          <p class="comment">There is no "swipe event". Created by the combination of touchstart, touchmove, and touchleave events</p>
          <p class="comment">** Touch events are complex and difficult to implement -- that's a relief since I find it hard to understand :)</p>
          <p>a. removeEventListener() - remove event listeners</p>
          <p>b. preventDefault() - is a method of the event object that can be used inside the callback function to stop the default behavior happening.<br>
          <span class="comment">**Be careful in using the preventDefault. Users may get confuse when certain behaviors they expect to happen don't happen.</span></p>
          </p>
          <p>5. Event Propagation - Capturing vs Bubbling</p>
          <p>bubbling - upwards- default behavior- when the event fires on the element clicked on first, then bubbles up the document tree, firing an event on each parent element until it reaches the root node.<br>
          capturing - downwards - starts by firing an event on the root element, then propagates downwards, firing an event on each child element until it reaches the target element that was clicked on.</p>
          <p>6. Event Delegation - attached an event listener to the parent element to capture events triggered by its child elements.</p>

  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  <script>
  WebFont.load({google: {families: ['Roboto', 'Source+Sans+Pro']}});
</script>
</body>
</html>